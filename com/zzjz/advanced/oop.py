# 封装
# 封装就是对对象的成员进行访问限制
# public  protected private
# public  protected private 不是关键字

# 私有：私有成员是最高级别的封装，只能在当前类或对象中访问
# 定义方式：在成员前面添加两个下划线即可
# Python 私有不是真私有，是一种name mangling 的改名策略，可以使用 _classname__属性名  来访问
# class Student():
#    sex = "女"
#    __age = 18
#   name = "你咋还"
# a = Student()
# print(a._Student__age)


# 受保护的封装 protected
# protected  可以在类或者子类中访问
# 方法：在成员名称前添加一个下划线即可


# 继承
# 继承就是一个类可以获得另外一个类中的成员属性和成员方法
# 作用：减少代码，增加代码的复用功能
# 被继承的类叫做父类，也叫基类、超类
# 用于继承的类叫做子类或者派生类
# 任何一个类都有一个共同的父类叫做object
# 继承的语法：父类写在子类的括号内
# 子类一旦继承父类，则可以使用父类中除私有成员外所有的属性或方法
# 子类可以定义独有的属性或方法
# 子类中如果存在于父类一样的成员，优先使用子类的成员
# 子类如果想扩充父类的方法，可以在定义新方法的同时访问父类成员来进行代码重用
# 可以使用 父类名.属性名来访问，或者使用super().属性来访问
# class People():
#    name = "jj"
# class Student(People):
#   pass
# t = Student()
# print(t.name)


# 构造函数
#  __init__ 就是构造函数，每次实例化时第一个被调用
# 构造函数至少需要一个参数，如果只有一个参数，那么这个参数默认就是self
# 实例化的时候默认调用自己的构造函数，如果自己未定义，则调用父类的构造函数

# super
# super 部署关键字，而是一个类
# super 的作用是获取MRO 列表中的第一个类
# class A():
#   pass
# class B(A):
#   pass
# class C(B):
#  pass
# class D(C,B,A):
#  pass
# print(A.mro())
# print(B.mro())
# print(D.mro())

# 菱形继承
# MRO 就是多继承中用于保存继承顺序的一个列表，MRO 自身排在第一位，其他的按照继承顺序排列
# python本身采用C3算法来计算多继承的菱形继承的计算
# MRO列表的原则
#    1、子类永远在父类前面
#    2、如果有多个父类，则根据继承语法中括号内的类的书写顺序存放
#    3、如果多个类继承了同一个父类，子孙类中只会选取继承语法括号中第一个父类的父类
#


# 多态
# 多态就是同一对象在不同的情况下有不同的状态出现
# python中的多态与java不一致

# Mixin 设计模式-主要采用多继承的方式对类的功能进行扩展
# 只是功能的增加并不改变它的类型

# python实现多继承的主要目的是扩展功能

# 使用Mixin实现多继承的特性
# - 必须表示某一单一功能，而不是某个物品
# - 职责必须单一，如果有过个功能，则写多个Mixin
# - Mixin不能依赖于子类的实现
# - 子类即使没有继承这个Mixin类，也能照样工作、只是缺少某个功能

# 优点
# - 使用Mixin可以在不对类进行任何修改的情况下扩充功能（模块化）
# - 可以方便的组织和维护不同的功能组件的划分
# - 可以根据需要，任意调整功能类的组合
# - 可以避免创建很多新的类，导致类的继承混乱

# issubclass 查看是否是某个类的子类
# isinstance 检查一个对象是否是一个类的实例
# hasattr 检测一个对象是否包含某个成员
# getattr 获取某个属性的值
# setattr 设置某个属性的值
# delattr 删除某个属性
# dir 获取对象的成员列表

